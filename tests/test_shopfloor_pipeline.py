"""
ShopFloor Pipeline Tests (Stub, CI-safe)
=========================================

Exercises ShopFloor pipeline mechanics without real Gemini/Claude.
Uses a MockPA that stubs _stream_claude to write files and return events.

Covers:
- BOM parsing and layer building (diamond dependency pattern)
- ShopFloor.produce() end-to-end with mock
- Quality gate SOP resolution
- Assembly merge of worktree branches back to parent
"""

import os
import subprocess
from typing import List, Optional

import pytest

from sf.models import EventType, OutputEvent
from sf.shopfloor import ShopFloor, build_layers, parse_work_orders
from sf.shopfloor.models import WorkOrder, WorkOrderResult
from sf.workstation import (
    GitRepoFixture,
    InspectionResult,
    SOP_V0,
    VerificationGate,
    Workstation,
)


# ---------------------------------------------------------------------------
# Fixed BOM text: 4 work orders, diamond dependency pattern
#
#   WO-0 (no deps)
#    / \
# WO-1  WO-2   (both depend on 0)
#    \ /
#   WO-3       (depends on 1 and 2)
# ---------------------------------------------------------------------------

DIAMOND_BOM = """\
1. Create project structure with src layout
2. Implement fibonacci iterative (depends: 1)
3. Implement fibonacci recursive (depends: 1)
4. Write tests for both implementations (depends: 2, 3)
"""


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _make_git_scaffold(tmp_path) -> str:
    """Create a minimal Python project with git repo.

    Returns the absolute path to the project directory.
    """
    project = str(tmp_path / "project")
    os.makedirs(os.path.join(project, "src", "fib"), exist_ok=True)
    os.makedirs(os.path.join(project, "tests"), exist_ok=True)

    with open(os.path.join(project, "pyproject.toml"), "w") as f:
        f.write('[project]\nname = "fib"\n')
    with open(os.path.join(project, "src", "fib", "__init__.py"), "w") as f:
        f.write("")
    with open(os.path.join(project, "tests", "__init__.py"), "w") as f:
        f.write("")

    subprocess.run(["git", "init"], cwd=project, capture_output=True, check=True)
    subprocess.run(
        ["git", "config", "user.name", "Test"],
        cwd=project, capture_output=True, check=True,
    )
    subprocess.run(
        ["git", "config", "user.email", "test@test.com"],
        cwd=project, capture_output=True, check=True,
    )
    subprocess.run(["git", "add", "-A"], cwd=project, capture_output=True, check=True)
    subprocess.run(
        ["git", "commit", "-m", "scaffold"],
        cwd=project, capture_output=True, check=True,
    )
    return project


class _MockPluginManager:
    """Minimal stub so ShopFloor plugin-hook guards pass harmlessly."""

    def trigger_hook(self, *args, **kwargs):
        return []

    def check_blocked(self, results):
        return False, ""


class _MockPA:
    """PA stub that records _stream_claude calls and writes dummy files."""

    def __init__(self, workstation: Workstation):
        self._workstation = workstation
        self._stream_claude_calls: List[tuple] = []
        self._plugin_manager = _MockPluginManager()

    def _stream_claude(
        self,
        instruction: str,
        working_dir: Optional[str] = None,
        iteration: int = 0,
    ):
        wd = working_dir or self._workstation.path
        self._stream_claude_calls.append((instruction, wd))

        # Write a dummy file to simulate Claude's work
        idx = len(self._stream_claude_calls)
        filepath = os.path.join(wd, f"wo_output_{idx}.py")
        with open(filepath, "w") as f:
            f.write(f"# Generated by WO {idx}\ndef func_{idx}(): pass\n")

        yield OutputEvent(
            event_type=EventType.TEXT,
            content=f"Completed work order: {instruction[:80]}",
            metadata={"source": "claude"},
        )


# ===================================================================
# Tests: BOM parsing and layer building
# ===================================================================


class TestParseAndBuildLayers:
    """parse_work_orders + build_layers on a diamond BOM."""

    def test_four_work_orders_parsed(self):
        bom = parse_work_orders(DIAMOND_BOM)
        assert len(bom) == 4

    def test_dependency_edges(self):
        bom = parse_work_orders(DIAMOND_BOM)

        assert bom[0].depends_on == []
        assert bom[1].depends_on == [0]
        assert bom[2].depends_on == [0]
        assert sorted(bom[3].depends_on) == [1, 2]

    def test_three_layers_built(self):
        bom = parse_work_orders(DIAMOND_BOM)
        layers = build_layers(bom)

        assert len(layers) == 3

    def test_layer_structure(self):
        bom = parse_work_orders(DIAMOND_BOM)
        layers = build_layers(bom)

        # Layer 1: WO-0 alone
        assert len(layers[0]) == 1
        assert layers[0][0].index == 0

        # Layer 2: WO-1 and WO-2 in parallel
        assert len(layers[1]) == 2
        assert sorted(wo.index for wo in layers[1]) == [1, 2]

        # Layer 3: WO-3 alone
        assert len(layers[2]) == 1
        assert layers[2][0].index == 3


# ===================================================================
# Tests: ShopFloor.produce() with MockPA
# ===================================================================


class TestShopFloorProduce:
    """Full produce() pipeline with _stream_claude stubbed out."""

    def test_stream_claude_called_once_per_wo(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        mock_pa = _MockPA(station)
        shopfloor = ShopFloor(pa=mock_pa)

        list(shopfloor.produce(
            task="Build fibonacci",
            breakdown_text=DIAMOND_BOM,
        ))

        assert len(mock_pa._stream_claude_calls) == 4

    def test_events_contain_shopfloor_markers(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        mock_pa = _MockPA(station)
        shopfloor = ShopFloor(pa=mock_pa)

        events = list(shopfloor.produce(
            task="Build fibonacci",
            breakdown_text=DIAMOND_BOM,
        ))

        shopfloor_events = [
            e for e in events if e.metadata.get("source") == "shopfloor"
        ]
        assert len(shopfloor_events) > 0

    def test_bom_and_layer_messages(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        mock_pa = _MockPA(station)
        shopfloor = ShopFloor(pa=mock_pa)

        events = list(shopfloor.produce(
            task="Build fibonacci",
            breakdown_text=DIAMOND_BOM,
        ))

        contents = " ".join(e.content for e in events)
        assert "Bill of Materials" in contents
        assert "4 work orders" in contents
        assert "3 execution layers" in contents

    def test_files_merged_into_parent(self, tmp_path):
        """Files written in child worktrees are merged back to parent."""
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        mock_pa = _MockPA(station)
        shopfloor = ShopFloor(pa=mock_pa)

        list(shopfloor.produce(
            task="Build fibonacci",
            breakdown_text=DIAMOND_BOM,
        ))

        wo_files = [
            f for f in os.listdir(project)
            if f.startswith("wo_output_") and f.endswith(".py")
        ]
        # WO-0 + WO-3 written directly to parent,
        # WO-1 + WO-2 written to worktrees then merged back.
        assert len(wo_files) == 4


# ===================================================================
# Tests: Quality gate SOP resolution
# ===================================================================


class TestQualityGateSOPResolution:
    """VerificationGate resolves commands from workstation SOP."""

    def test_station_with_sop_resolves_commands(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture, sop=SOP_V0)
        station.commission()

        gate = VerificationGate()
        commands = gate._resolve_commands(station)

        assert len(commands) > 0
        assert commands == SOP_V0.verification_commands

    def test_station_without_sop_returns_empty_commands(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        gate = VerificationGate()
        commands = gate._resolve_commands(station)

        assert commands == []

    def test_station_without_sop_auto_passes_inspection(self, tmp_path):
        project = _make_git_scaffold(tmp_path)
        fixture = GitRepoFixture(path=project)
        station = Workstation(fixture=fixture)
        station.commission()

        gate = VerificationGate()
        wo = WorkOrder(index=0, prompt="test task")
        result = WorkOrderResult(status="completed", work_order_index=0)

        inspection = gate.inspect(wo, result, station)

        assert inspection.passed is True
        assert "No verification commands" in inspection.details
